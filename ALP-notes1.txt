Assembly Language Instructions:
======================
1.An assembly language has 2 parts:
	Part1: Defines the operation to be performed and is represented by the memonic of the instruction:
		example: movl %eax, %ebx
		In the above example movl is the operation to be performed 
	Part2: Defines the operands for the instruction

2. Operands of Instructions are 2 Types:
	Type1: Source Operands: Provides Input values to the operation to be performed.
	Type: Destination Operands: Results of the operation are stored in destination Operands

3. In an Instruction destination & Source operands:
	A. May be same	: addl %ebx, %ebx (addl the current values of %ebx and store the result in %ebx)
	B. May be different   : addl %ebx, %ecx (add the values in ebx and ecx and store the result in ecx)

4. As instructions are assembled by the assembler, A track of Memory addresses of instructions are maintained. 

5. Some instructions such as "jump" or "call" have the memory address of anohter instructions as argument. It's difficult for programmer to keep track of
these addresses , So instructions are labelled, and this label is referred in Other instructions:

1. .section .data
2. .section .text
3. .globl _start
4. _start:
5.        movl $1, %eax  
6.        movl $100, %ebx 
7,.       int $0x80      

In the above code , the instructions from lines 5,6,7 are labelled with "_start": 

6. _start defines the address of the instruction in line 5:

Example:

08048054 <_start>:
 8048054:       b8 01 00 00 00          mov    $0x1,%eax
 8048059:       bb 64 00 00 00          mov    $0x64,%ebx
 804805e:       cd 80                   int    $0x80
 
7. An assembly instructions also several Non-Processor instructions used in the program, which are called pseudo-ops or assembler directives. 

example: ".section data" , ".section .text"  etc.

8. _start is a symbol to define address of the instruction in the program that is executed first. Thus the execution of the program always starts from location "_start" 
and carries on till the program makes a call to exit system call in GNU/Linux

Example:

08048054 <_start>:
 8048054:       b8 01 00 00 00          mov    $0x1,%eax
 8048059:       bb 64 00 00 00          mov    $0x64,%ebx
 804805e:       cd 80                   int    $0x80
 
 As you see from the above example: _start symbol is pointing to  "08058054", "08058054" is the starting addres of the first instruction to be executed that is Line:5

Operand Sizes:
==========
1. In IA-32 Architecture: instructions can have operands of variable sizes. 
	Example: 
		i)8-bit operands	known as: byte
		ii) 16-bit 			known as: word
		iii)32-bit			known as: long

	
2. Instructions in IA32 architecture of 0,1 or 2 Operands

3. Operands may be:
	i) Registers		Example: movl %eax, %ebx
	ii) Memory		Example: movl myval, %ebx
	iii) Constants		Example: addl 5,%ebx

4. Register operands can be: 
	8-bit registers: al,ah,bl,bh,cl,ch,dl,dh	
	16-bit registers: ax, bx,cx,dx,di,si,sp, bp
	
5. Instructions can have:
	i) No operand
	ii) Multiple Operands

6. All instructions can have only 1 Memory operand. 

	examples:
	A.  if instruction has only 1 operand:
		incl myval  (value in myval will be incremented by 1)
	B. Multiple operands:
		incl %ebx, myval

7. For instructions which have 2 operands , they can have 1 memory , & other may be constant or register
	examples: 
	addl %ebx, myval
	addl 5,myval

Memory Model:
===========
1. Memory in a computer system can be thought as an Array of bytes:
	
|--------------------------------------------------------------------------------------------------------------------------------------------------|
|   A	|   B	|   C	|    1	|   2	|   3	|    4	|   @	|   S	|   8	|   11	|   1	|  13	|  15	|  H	|  E	|   L	|   L	|   O |   B 	|  Y 	|  E	|
|---0-----1-----2------3-----4-----5-----6------7-----8----9-----10----11----12---13---14----15----16----17---18----19---20---21--|

Index of this array: (example, 0,1,2,3) are known as address:
Value of the Array element : A, B,C are known as content of the memory location

So Address 0,the value A is stored
Address 1, Value B i stored
Address 17, Value L is stored. 

2. Instructions may have operands in the memory, so memory addresses of the operands are specified in the instruction, Ways to specify address in , instruction will
be dealt later

3. IA32 supports 2 kinds of Addressing mechanism
	1. 16-bit wide: 
	Leave this, Not Important
	2. 32-bit wide addressing 
4. OS ues only 1 kind of addressing mechanism., GNU/Linux uses 32-bit addressing Mechanism. In this addressing mechanism, the range of memory addressability
is 2^32 bytes

|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   A	|   B	|   C	|    1	|   2	|   3	|    4	|   @	|   S	|   8	|   11	|   1	|  13	|  15	|  H	|  E	|   L	|   L	|   O |   B 	|  Y 	|  E	|	|	|	|	|	| 
|---0-----1-----2------3-----4-----5-----6------7-----8----9-----10----11----12---13---14----15----16----17---18----19---20---21------------------------------2^32-

5. Operands can be of  1 or more size bytes:
	If operand is 1 byte: 1 memory location is used
	If operand is more than 1 byte, Multiple memory locations will be used. 
	
	Example: 16-bit operand will use 2 memory locations:

Example: In the above diagram, to store HELLO, 5 Memory locations are used. 5 bytes are used. 

6. The memory operands are specified using 2 Attributes:
	A. Start Address (Specifically Mechanism to compute the start Address)
	B. size 
	
7. 16-bit Operands has 2 bytes: The most significant byte and Least significant byte. 

8. IA32 use Little-endian, LSB is stored in Lower Address. 

9. Example:
16-bit number: 0x1245	, So 0x45 will be stored in lower order : 0x23C8 , and 0x12 will be stored in 0x23C9

|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
|   A	|   B	|   C	|    1	|   2	|   3	|    4	|   @	|   S	|   8	|   11	|   1	|  13	|  15	|  H	|  E	|   L	|   L	|   O |   B 	|  Y 	|  E	|	|	|	|	|	| 
|---0-----1-----2------3-----4-----5-----6------7-----8----9-----10----11----12---13---14----15----16----17---18----19---20---21------------------------------2^32-

In the above representation
If the number 1513 has to be stored:

Lowest address: 12: will have 13
Next higher address: 13: will have 15
===================================================================================================
Operand Addressing:

1. Instructions in IA32 processor operate on operands & generate at most 1 result. Results are then stored on memory or as specified in location

Instruction----->Processor->(Get operands, as per instruction & do operation)
				| Output
			____|__________
                        |                         |
               Memory                    Registers

2. Instructions can have :
	A. No destination operand
	B. Implied destination operand
	C. 1 destination Operand 

3. Instructions can have:
	A. 0 Source operand
	B. 1 Source operand
	C. 2 source operands
	
4. Mechanism of addressing operands indicates the way operands are found during the execution of instructions . Also known as addressing mode
of processors

5. Addressing modes are encoded in instruction. During execution of instruction the actual values are taken using the addressing modes specified:

6. Categories of operands:
	A. Constant 
		Example: add $5, %eax 
	All constants have $ sign prefixed 
	
	B. Registers
		examples: incl %eax, 
		add %ebx, %ecx
		movl %eax, %ebx
	All registers in the instruction are prefixed with % 
	
	C. Memory
		Examples: 
		movl data_items(,%ecx,4), %eax
		movl  data_items, %eax


Different Addressing modes
------------------------------------
1. Immediate Addressing : All constant operations of an instruction are specified using the immediate addressing mode. Constant operands are
prefixed with $sign

Examples: 
addl $5, %eax

In the above example 5 is added to the value stored in %eax and result is saved in eax register

cmpl $5, %eax
In the above example 5 is compared with value stored in eax register and eflags register is used to store the result

2. Register Addressing mode: 

Register operands (%eax, %ebx) are specified in instruction by name of registers. 

examples:
addl %eax, %ebx
cmpl %eax, %ebx
movl %eax, %ebx
32-bit registers: eax, ebx,ecx,edx,
16-bit, ax,cx,dx,si,di,sp & bp 
8-bit: al,ah, cl, ch, dl,dh 

3. Memory Addressing: 
	i)When an operand of the instruction is stored in memory, It is read from (or written to) to the memory during the execution 
	ii) Instruction should also specify the method to compute memory address also known as effective address

Methods to compute the address:	

3.1: Direct Addressing:
------------------------------
1. Simplest method of Providing the address is to specify that address in the instruction:
	Example: addl 0x8048054, %eax
	In the above example 0x8048054 is theaddress in memory having a value 5(for example) which will be added to the contents of eax and the result tant
	value is stored in eax
	
2. 	Since it's difficult to memorize the addresses , we use symbolic names for addresses , Linker then assigns the final address before execution

Example: addl data_items, %eax
data_items is a symbolic name for an address that contains 5(for example) that will be added to eax

3. Example: addl 20, %eax 

In the above example there is no $ prefixed for 20, so it's treated as address, Since the second operand is %eax, which is 32-bit register, the first operand
is also treated as 4 byte operands, So values stored from starting from 20,21,22,23 are fetched. 

4. While using memory addressing, the effective address provides just the starting address of the operand in the memory. 

5. The instruction should also provide the size of the operand , In most cases size of the operand is implicit
Examples:
	addl 20, %eax (In this case the size of the memory operand is implicit, which is actually based on 2nd operand)
	movb 20, %al  (in this case the size of the memory opeand is 1 byte,)
	incl 20 (In this case the size of the memory operand is 4 bytes starting from 20)
	incb 20  (size of memory operand is 1 byte which address 20)

Components of Effective Address
------------------------------------------
1. Effective address can be provided by specifying 4 different components:
	A. 2 Registers
	B. 2 constants

2. Two Registers are used as "base" & "index" component  , while the constants are used as "scale" & "displacement" . 

base(Register) ,  Index (Register), Scale (Constant), Displacement (Constant)

3. Scale can have values: 	1,2,4,8

4. Displacement can have values of : 8-bit or 32-bit

5. From the 4 values we defined above (base, index,scale, displacement) up to 3 can be ommitted 

6. Direct Addressing is an example where effective address is computed by omitting base, index & scale and only 32-bit displacement being used. 

7. Any of the 8 General Purpose registers can be used for "base" component  (eax,ebx,ecx,edx,esi,ebp,esp,ebp)

8. For Index only 7 General Purpose registers can be used : eax,ebx,ecx,edx,esi,edi,ebp. 

9. Displacement is a signed Number: so values range from -128 to +127 

10. In GNU/Linux Assembly language  Memory operand can be computed using below syntax:

Effective address: displacement(base,index,scale)

3.2 Indirect Addressing: (Base/Registers) Or Register Indirect method
------------------------------------------------------------------------------------------

1. If the memory operand is specified using just the base component (i.e only registers) 

example:
mov (%eax), %ebx 

In the above example Memory address is stored in eax , size is 32-bit 
add eax, (%ecx)

Note: addl (%ecx), (%ebx) is not allowed as assembly instruction can have only 1 memory operand 

Assume the memory image:

| 0x50BF	| 0x50C0	| 0x50C1	| 0x50C2	| 0x50C3	|
-------------------------------------------------------------------
| 0x10	| 0xE3	|0x20	| 0x00	| 0x10	|
-------------------------------------------------------------------

Consider:
	eax: 0x20 
	ecx: 0x50C0
	
	Instruction addl %eax, (%ecx) 
	The above causes 32-bit number from 0x50C0 to be read , and 0x20 be added to that value , and then stored back the result from 0x50C0
	Since it's 32-bit so 0x50C0 to 0x50C3 will be read and also the same is used to store the result. 
	 
3.3 Base + Displacement:
-------------------------------------

1. If the memory operand is computed using base & Displacement , then 
	effective address: displacement + base

2. Example: addl 2(%ebp) 

In the above example: displacement=2, base is ebp 

3. Consider the below memory Image:

| 25		| 26		| 27		| 28		| 29		|
-------------------------------------------------------------------
| 0x10	| 0xE3	|0x20	| 0x00	| 0x10	|
-------------------------------------------------------------------

If the ebp has 25 ,  then 25 is added to 2  , so the effective address is 27, since it's 32-bit register 4 bytes from 27 is read. 

Consider example:

addb 10, 2(%ebp)

In the above example:  the effective address of 2nd operand is (if ebp is 25), 27 (25 + 2) , since the instruction has "movb" , then only 1 byte is read starting from 
27 and added to 10 and result is stored in ebp 


Example Code 1:

.section .data
var1:
.int 25,27,28,29,30
.section .text
.globl _start
        _start:
                movl $var1, %ecx
                movl 8(%ecx), %ebx
                movl $1, %eax
                int $0x80

Example Code: 2
----------------------
.section .data
var1:
.long 25,26,27,28
.section .text
.globl _start
        _start:
                movl $var1, %edi 
                movl (%edi), %eax
                movl 4(%edi), %ebx 
                movl 8(%edi), %ecx 
                movl 12(%edi), %edx
                movl $1, %eax    
                int $0x80       
====================================================================================================
Index*Scale+ displacement:
 
1. If the memory operand is specified using index,scale & displacement components, the effective address is computed by multiplying the index by scale 
& then adding the displacement. 

2. Scale can take values: 1,2,4,8 

3. Index can have all General purpose registers except "esp"

4. If an array is used where the size of the element is 1,2,4 or 8 bytes , then element of array can be accessed using this mode. 

Consider Example:

# Registers:
# %edi points to starting address of an array
# %esi will be used as index register

.section .data
var1:
.int 10,11,12,13
.section .text
.globl _start
        _start:
                movl $var1, %edi			#we are passing address of var1[0] to %edi
                						#Assume the address of var1[0]=134516928/0x80490c0 
                						
                movl $0, %esi          		 #Since Index should be a register, We access first element var[0], so esi gets 0
                addl $1, var1(,%esi,4)  		#index(%ecx)=0,scale=4 , because 4 is total storage location taken by each element of array
				                                #displacement=var1 i,e starting address(134516928)
			                                        # var1(,%ecx,4) ==>> starting address(,0,4)
                        			                #=>>displacement(startingaddres)[0+0*4]=> starting address(134516928)
                        			                
                        			                
                movl (%edi), %eax			# here %edi=0x80490c0/134516928 , %eax will have 11

                movl $1, %esi        			   #We need to move to next array element %esi=1
                addl $1, var1(,%esi,4)  		  #displacment(starting address)[0+1*4]=>(starting address+4) now adding 1 to the value (134516928 + 4)
                						  # 134516928 + 4=134516932, Value stored at address 134516932 is 11,  Add 1 to 11 and store it  back at 134516932
                  		                                  # stored in (Starting address+4) 134516932, so 12 is stored 

                movl 4(%edi), %ebx      		#copy the net result in %eax , edi=134516928, 4+134516928=134516932, value at 134516932 is 12 

                movl $2, %esi           		#we move to var1[2] now, i.e 3rd element. 
                addl $1, var1(,%esi,4)  		#displacement(0+2*4)  134516928(0+2*4) 134516928(0+8)=>134516928 + 8 => 134516936
                						# Value stored at 134516936 is 12, Add 1 to 12 and result is stored back at 134516936 ie. 13. 

                movl 8(%edi), %ecx			# Access 3rd element and store it in ecx. %edi=134516928, 134516928+8=134516936,i.e get value 13 and store it in ecx
                
                
                movl $3, %esi         			# we move to var1[3] now
                
                addl $1, var1(,%esi,4)		# displacement=var1 (starting address), %esi=3(index), scale=4  
                						#	134516928(0+3*4)
                						# effective address=displacement+[base+index * scale]
                						# EA=displacement+[0+3*4]
                						# EA=displacement+[0+12] => displacement+12 134516928 + 12=134516940
               movl 12(%edi), %edx		

                movl $1, %eax
                int $0x80

Another Example:

We are adding all the values in the array var1 and store it in %ebx, var1 is accessed using displacement(index*scale)
.section .data
var1:
.int 10,11,12,13
.section .text
.globl _start
        _start:
                movl $var1, %edi
                movl %edi, %ecx
                movl $0, %esi   #Since Index should be a register, %esi will be index register
                addl $12, %ecx  # we need ending address to come out of loop
                movl (%edi), %ebx
        start_loop:
                cmpl %edi, %ecx
                je loop_exit
                incl %esi
                addl var1(,%esi,4), %ebx
                addl $4, %edi
                jmp start_loop
        loop_exit:
                movl $1, %eax
                int $0x80

===================================================================================================                
Base+index*scale:
1. In this addressing mode, 3 components base, index & scale are provided and effective address is computed by the processor while executing the instruction. 

2. Two components base & index are provided by registers , Scale is constant

Examples:
.section .data
var1:
.int 10,11,12,13
.section .text
.globl _start
        _start:
                movl $var1, %edi        #we copy the starting address in %edi
                movl $0, %esi           #Since Index should be a register, The first element var[0], so ecx gets 0

                addl $1, (%edi,%esi,4)  #index(%esi)=0,scale=4 , because 4 is total storage location taken by each element of array
                                        #displacement=0 
                                        # var1(%edi,%esi,4) ==>> starting address(starting address+0*4)
                                        #[0+0*4]=> starting address=>%edi
                movl (%edi), %eax
                movl $1, %esi           #We need to move to next array element
                addl $1, (%edi,%esi,4)  #[starting+1*4]=>(starting address+4) now adding 1 to the value
                                        # stored in (Starting address+4)

                movl 4(%edi), %ebx      #copy the net result in %eax

                movl $2, %esi           #we move to var1[2] now
                addl $1, (%edi,%esi,4)  #displacement(0+2*4)
                movl 8(%edi), %ecx

                movl $3, %esi           # we move to var1[3] now
                addl $1, (%edi,%esi,4)
                movl 12(%edi), %edx

                movl $1, %eax
                int $0x80

====================================================================================================
Base+Index*scale+Displacement:

1. This mode of addressing in IA32 processors is most powerful mode, In this mode all the four components are specified & the effective address is computed
using 2 additions & 1 multiplication 

2. This addressing involves 2 registers and 2 constants
3. Registers are used for address information
4. Constants are used for displacement & scaling

5. This addressing mode can be used to address an element from a 2-D Array 

Example:

Consider 2 * 4 Matrix as below:

		j	0		1		2		3
		-----------------------------------------------------
	0	|	12	|	13	|	14	|	15	|
i		------------------------------------------------------
	1	|	16	|	17	|	18	|	19	|
		------------------------------------------------------

Size of the Array => 2 * 4 

In memory the above array is stored in Row major format, in which the array elements are stored in memory in the row-first order.  Example as below:

matrix		value	Address;
----------------------------------------------
A0,0	|	12	|	20
A0,1	|	13	|	21
A0,2	|	14	|	22
A0,3	|	15	|	23
A1,0	|	16	|	24
A1,1	|	17	|	25
A1,2	|	18	|	26
A1,3	|	19	|	27

Assuming the size of each element is denoted by "s"

A[0][0] is denoted as "A" and size is 1 byte, then Address of A[0][1]=A +s ===> So if A[0][0]=20, then A[0][1]=>20+1=21

Address of A[0][j]	is (A+j)*s, So address of A[0][n-1] or A[0][4-1] ==>A[0][3]= (A+j)*s=> (20+3)*1=> 20+3=23

Each Row of the array occupies n*s bytes Which implies from the above example: each row occupies 4 bytes
Address of Row 1 (j) will be A+n*s
Address of first element of  Row i is A* i*n*s
Generalized form of A[i][j] => A+i*n*s+j*s

1 Registers is to keep i*n*s, this provides offset of the starting address of row i
Index register is used to keep j

s or size is represented by scale 

Starting Address of array(A) can be given by displacement 

====================================================================================================
Functions:
------------
1. To assist programmers in working together in groups, It is necessary to break programs apart into separate pieces,  Which communicate with each
other through well-defined interfaces

2. Functions are units of code that do a defined piece of work on specified types of data. 

3. Data items(inputs) a function is given to process are called it's parameters

4. A typical program is composed of thousands of functions, each with a small, well-defined task to perform. However ulitmately there are things that 
one cannot write functions for which must be provided by the system. Those are called primitive functions. They are basics which everything else is built
of. 

Functions are composed of below Elements:
--------------------------------------------------------
A. Function Name:
B. Function Parameters
C. Local variables
D. Static variables
E. Global Variables
F Return Address
G. Return Value
									---------------------------
									|				|
									|	Functions		|	
									----------------------------
											|
|---------------------------------------------------------------------------------------------------------------------------------------------------------------|									
		|				|			|			|			|			|				|
	Function Name		Function 		      local		      static 	 	     Global		Return Address	Return Value
					Parameters	      variables	     variables          variables


A. Function name:
-----------------------
	i.	Functions name is a symbol that represents the address where the function's code starts
	ii.	In ALP symbol is defined by typing the functions name followed by colon immediately before function's code. 
	
	Example:

	.section .text
	.globl _start
		_start:		<-------------------_start is a function which symbolises address of the instruction "movl $101, %ebx"
				movl $101, %ebx
				movl $1,	%eax
				int $0x80
	objdump -d ./exit

	./exit:     file format elf32-i386

	Disassembly of section .text:

	08048054 <_start>:
	 8048054:       b8 01 00 00 00          mov    $0x1,%eax
	 8048059:       bb 64 00 00 00          mov    $0x64,%ebx
	 804805e:       cd 80                   int    $0x80
	 
	 As we can see from the above dissembly, _start points to Address 8048054 which is the address of the instruction "mov   $0x1,%eax"

B. Function Paramters
----------------------------
	i.	A function's parameters are the data items that are explicitly given to the function for processing
		example:
			 sine(2) = 0.34
			 
			 sine is the name of the function
			 2 is the paramter 
	ii.	Some functions have many parameters
	iii.	Some functions have no parameters

C. local variables
-----------------------
	i.	Local variables are data storage that a function uses while processing
	
	ii.	This data storage  is thrown away when function execution is completed (or returned)
	
	iii.	It's like rough paper which we get everytime function is evoked, Once completed , the rough paper is discareded. 
	
	iv.	Local variables of a function cannot be accesssed by any other function 

D. Static variables
-------------------------
	i.	Static Variables are data storage that function uses while processing

	ii.	This data storage is not thrown away when function completes it's execution
	
	iii.	This data storage is re-used everytime the function is activated 
	
	iv.	This data stroage cannot be accessed outside of the function. 
	
	v.	This data storage should be used with caution

E. Global Variables
------------------------
	i.	Global Variables are data storage that function uses while processing
	
	ii.	This data storage is available outside of the function execution, i.e this data storage is available to other functions also
	
	iii.	This data storage is thrown away when the whole program completes execution
	
	Examples:
	
	i.	A simple text editor may put the entire contents of the file it is working on a global variable so it doesn't have to be passed to every function that 
	operates on it. 
	
	ii.	Configuration values are often stored in global variables.

F. Return Address
-----------------------
	i.	Return Address is an invisible parameter 
	
	ii.	Return Address is not directly Used by the function during execution
	
	iii.	Return address is used to find where the processor should start executing after the function completes it's execution
	
	iv.	This is needed because function can be called to execute from different parts of the program , once the function completes execution, it should 
		go back to where it was called from. 
	
	v.	In most programming languages, this parameter is passed automatically when the function is called

G. Return Value
---------------------
	
	i.	Return Value is main method of tranferring data back to main program
	
	ii.	Most programming languages allow a single return value for a program 
	


5. The above pieces of a function are mostly same for different programming languages , How each pieces are specified are different in each one. 

6. The variables(local,global &  Static), Function Paramters & Return values are tranferred between functions vary from language to language. This variance 
is called "calling convention"	

7. Calling convention describes how functions expect to get & receive data when they are called

8. Assembly language can use any calling convention 

9. C calling Convention is mostly used 

10. To understand how functions work, It's important to understand how "stack" work.  

11. Each computer program that runs uses a region of memory called the stack to enable functions to work properly.

Stack:
--------
	i.	Stack is a pile of papers on desk , which can be added to indefinitely 
	
	ii.	Things that we are working currently is always on the top. 

	iii.	Computers have stack too, computers stack lives at the very top address of Memory 

	iv.	we can add values (also called push) values on to the stack using instruction called "pushl" 
	
	v.	pushl pushes either a register(eax,ebx,ecx...etc) or value on to the top of the stack.
	
	vi.	Nomencalature used in stack like "top" is actually (physically) the bottom of the stack's Memory
	
		________________________________________________
		|29 		|28		|27		|26		|25		|25	 	|
		| ----------	| ----------	| --------	| ----------	| ----------	| ----------	| <--------Stack
		|23		|22		|21		|20		|19		|18		|<--------------------------------Top
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	|
		|17	@	|16	!	|15	F	|14	)	|13	G	|12	H	|
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	|
		|11	H	|10	E	|9	L	|8	L	|7	O	|6	W	|
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	| 
		|5	O	|4	R	|3	L	|2	D	|1	!	|0	!	|	
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	| 

	vii. 	From the above Memory representation We can see that 
		A. Memory addressing starts from 29 and moves down to 0 (more like fffffff to 0000000)
		B. Top is bottom of the memory 
		C. Memory grows Downwards
 
	viii. When we are referring top of the	stack we are actually referring to bottom of the memory
	
	ix.	We can also remove values from the stack , which is called as "pop" , instruction used is "popl"
	
	x.	When we push a value on to the stack, the top of the stack moves to accomdate the addition value. 
	
	xi.	Stack can be kept on pushing until we hit our code or data. 
	
	xii. 	To know where the "top" of the stack is , we use a stack register %esp , which always points to the current top of the stack
	
	Examples:

		--------------------------------------------------------------------------------
		|29 	H	|28		|27		|26		|25		|25	 	|
		| ----------	| ----------	| --------	| ----------	| ----------	| ----------	| <--------Stack
		|23		|22		|21		|20		|19		|18		|
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	|
			
			In the above example We added H to the stack, So now top (%esp) points to address 29

		--------------------------------------------------------------------------------
		|29 	H	|28	E	|27		|26		|25		|25	 	|
		| ----------	| ----------	| --------	| ----------	| ----------	| ----------	| <--------Stack
		|23		|22		|21		|20		|19		|18		|
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	|			

		We added(pushed) E to the stack, So now top (%esp) points to E
		
		--------------------------------------------------------------------------------
		|29 	H	|28	E	|27	L	|26	L	|25	O	|25	W 	|
		| ----------	| ----------	| --------	| ----------	| ----------	| ----------	| <--------Stack
		|23	O	|22	R	|21	L	|20	D	|19		|18		|
		| ----------	| ----------	| ----------	| ----------	| ----------	| ----------	|

		As you can see from the above example we kept pushing characters to stack. 
		Now top(%esp) of the stack points to Address 20 (or value D)				

	xiii.	pushl instruction pushes 4 bytes of value on to the stack , Since we are moving down the memory , Pushing value is basically subtracting by 4 
		when we do pushl, %esp gets subtracted by 4 , 
		note: pushl (push long i.e 4 bytes)

	xiv.	To  remove something from stack , we simply popl from the stack , which is basically adding 4 bytes to %esp

	xv.	To access current value (or topmost value in stack) , We can access %esp register
		
		example:
			movl (%esp), %eax
		The above will move what ever value is in the top of the stack to %eax register
		
	xvi.	If we do the operation, 
			movl %esp, %eax
		The above will copy the address to which currently top points to %eax register. 
		
